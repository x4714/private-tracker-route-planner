<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Private Tracker Route Planner</title>

  <meta name="description" content="Find the fastest and shortest routes between private trackers. Official TrackersInfo recruitment and route planner tool." />
  <meta name="keywords" content="private trackers, tracker route, trackersinfo, torrent trackers, tracker jumps" />
  <meta name="author" content="TrackersInfo" />

  <!-- Open Graph -->
  <meta property="og:title" content="Private Tracker Route Planner" />
  <meta property="og:description" content="Calculate optimal routes between private trackers using TrackersInfo data." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://github.com/x4714/private-tracker-route-planner" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Private Tracker Route Planner" />
  <meta name="twitter:description" content="Fastest and fewest-jumps tracker route calculator." />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <header>
    <h1>Private Tracker Route Planner</h1>
    <p>Official TrackersInfo recruitment route calculator</p>
  </header>

  <div id="routeContainer">
    <div id="calcForm">
      <div id="headerSection">
        <div class="input-group">
          <label class="input-label">From</label>
          <input type="text" class="tracker-input" id="sourceInput" placeholder="Any tracker (comma-separated)">
          <div id="sourceDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>

        <div class="arrow-separator">→</div>

        <div class="input-group">
          <label class="input-label">To</label>
          <input type="text" class="tracker-input" id="targetInput" placeholder="Any tracker">
          <div id="targetDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
      </div>

      <div id="resultsInfo"></div>
      <div id="routesGrid"></div>
    </div>
  </div>

  <div id="settingsMenu">
    <div class="setting">
      <label>Max Jumps</label>
      <div class="radio-group" id="maxJumpsRadios">
        <label><input type="radio" name="maxJumps" value="1">1</label>
        <label><input type="radio" name="maxJumps" value="2">2</label>
        <label><input type="radio" name="maxJumps" value="3">3</label>
        <label><input type="radio" name="maxJumps" value="4">4</label>
        <label><input type="radio" name="maxJumps" value="5">5</label>
      </div>
      <input type="number" id="maxJumpsInput" value="5" min="1">
    </div>

    <div class="setting">
      <label>Max Days</label>
      <div class="radio-group" id="maxDaysRadios">
        <label><input type="radio" name="maxDays" value="180">6m</label>
        <label><input type="radio" name="maxDays" value="360">1y</label>
        <label><input type="radio" name="maxDays" value="720">2y</label>
        <label><input type="radio" name="maxDays" value="1800">5y</label>
        <label><input type="radio" name="maxDays" value="3600">10y</label>
      </div>
      <input type="number" id="maxDaysInput" value="1080" min="1">
    </div>

    <div class="setting">
      <label>Sort By</label>
      <div class="radio-group" id="sortRadios">
        <label><input type="radio" name="sortOption" value="fastest">Fastest</label>
        <label><input type="radio" name="sortOption" value="fewestJumps">Fewest Jumps</label>
      </div>
    </div>
  </div>

  <div class="footer-info">
    <span id="update-time">Loading...</span>
    <a href="https://www.reddit.com/r/TrackersInfo/wiki/official_recruitments/" target="_blank">TrackersInfo</a>
    <a href="https://github.com/x4714/private-tracker-route-planner" target="_blank">GitHub</a>
  </div>

  <script>
    // --- Mock Data (For immediate testing if fetch fails) ---
    const MOCK_DATA = {
      "unlockInviteClass": {
        "BTN": [365, "Elite"],
        "PTP": [365, "Master"],
        "RED": [0, "User"],
        "GGN": [0, "User"],
        "MTV": [365, "Power User"],
        "OPS": [365, "Elite"],
        "AHD": [0, "User"]
      },
      "abbrList": {
        "BroadcasTheNet": "BTN",
        "PassThePopcorn": "PTP",
        "Redacted": "RED",
        "GazelleGames": "GGN",
        "MoreThanTV": "MTV",
        "Orpheus": "OPS",
        "Anthelion": "AHD"
      },
      "routeInfo": {
        "RED": {
          "OPS": { "reqs": "None", "days": 90, "active": "Yes", "updated": "2023-10-15" },
          "MTV": { "reqs": "None", "days": 60, "active": "Yes", "updated": "2023-09-20" },
          "GGN": { "reqs": "None", "days": 30, "active": "No", "updated": "2023-08-05" }
        },
        "OPS": {
          "BTN": { "reqs": "Elite + 6mo", "days": 180, "active": "Yes", "updated": "2023-10-01" },
          "PTP": { "reqs": "Master + 12mo", "days": 365, "active": "Yes", "updated": "2023-10-10" }
        },
        "MTV": {
          "PTP": { "reqs": "Power User+ + 24mo", "days": 365, "active": "No", "updated": "2023-07-15" },
          "AHD": { "reqs": "None", "days": 90, "active": "Yes", "updated": "2023-09-01" }
        },
        "GGN": {
          "BTN": { "reqs": "None", "days": 120, "active": "Yes", "updated": "2023-10-05" }
        },
        "AHD": {
          "PTP": { "reqs": "Elite", "days": 180, "active": "Unknown", "updated": "2023-01-01" }
        }
      }
    };

    window.addEventListener('load', async function () {
      let data;
      try {
        const response = await fetch('trackers.json');
        if (!response.ok) throw new Error("File not found");
        data = await response.json();
      } catch (error) {
        console.warn('Using mock data as trackers.json is missing:', error);
        data = MOCK_DATA;
      }

      const sourceInput = document.getElementById('sourceInput');
      const targetInput = document.getElementById('targetInput');
      const sourceDropdown = document.getElementById('sourceDropdown');
      const targetDropdown = document.getElementById('targetDropdown');
      const maxJumpsInput = document.getElementById('maxJumpsInput');
      const maxJumpsRadios = document.querySelectorAll('#maxJumpsRadios input');
      const maxDaysInput = document.getElementById('maxDaysInput');
      const maxDaysRadios = document.querySelectorAll('#maxDaysRadios input');
      const sortRadios = document.querySelectorAll('#sortRadios input');
      const resultsInfo = document.getElementById('resultsInfo');
      const body = document.body;

      let sourceDebounceTimer;
      let targetDebounceTimer;

      const { routeInfo, unlockInviteClass, abbrList } = data;

      let maxJumps = parseInt(localStorage.getItem('maxJumps'), 10);
      let maxDays = parseInt(localStorage.getItem('maxDays'), 10);
      let sortOptionValue = localStorage.getItem('sortOption');

      const urlParams = new URLSearchParams(window.location.search);
      const fromParam = urlParams.get('from');
      const toParam = urlParams.get('to');
      const jumpsParam = parseInt(urlParams.get('jumps'), 10);
      const daysParam = parseInt(urlParams.get('days'), 10);
      const sortParam = urlParams.get('sort');

      if (fromParam) sourceInput.value = fromParam;
      if (toParam) targetInput.value = toParam;
      if (!isNaN(jumpsParam)) maxJumps = jumpsParam;
      if (!isNaN(daysParam)) maxDays = daysParam;
      if (sortParam) sortOptionValue = sortParam;

      if (isNaN(maxJumps)) maxJumps = 4;
      if (isNaN(maxDays)) maxDays = 720;
      if (!sortOptionValue) sortOptionValue = 'fastest';

      const allTrackers = Array.from(new Set(
        Object.keys(routeInfo)
          .flatMap(startKey => [startKey, ...Object.keys(routeInfo[startKey])])
      )).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

      const allTrackersLower = allTrackers.map(t => t.toLowerCase());

      // Helper to get abbreviation
      function getAbbr(name) {
        if (abbrList[name]) return abbrList[name];
        const capitals = name.match(/[A-Z]/g);
        if (capitals && capitals.length >= 2) return capitals.join("");
        return name.substring(0, 3).toUpperCase();
      }

      // --- Event Listeners ---

      document.addEventListener('mousedown', (event) => {
        if (!sourceDropdown.contains(event.target) && !sourceInput.contains(event.target)) {
          sourceDropdown.style.display = 'none';
        }
        if (!targetDropdown.contains(event.target) && !targetInput.contains(event.target)) {
          targetDropdown.style.display = 'none';
        }
      });

      [sourceDropdown, targetDropdown].forEach(dropdown => {
        dropdown.addEventListener('mousedown', (e) => e.stopPropagation());
      });

      const handleInputActivity = () => {
        const hasValue = sourceInput.value.trim().length > 0 || targetInput.value.trim().length > 0;
        if (hasValue) {
          body.classList.add('is-searching');
        } else {
          body.classList.remove('is-searching');
          body.classList.remove('has-results');
          resultsInfo.style.opacity = '0';
        }
        updateURL();
      };

      sourceInput.addEventListener('input', (e) => {
        clearTimeout(sourceDebounceTimer);
        const value = e.target.value;
        sourceDebounceTimer = setTimeout(() => {
          showAutocomplete(sourceInput, sourceDropdown, value);
          handleInputActivity();
        }, 150);
      });

      targetInput.addEventListener('input', (e) => {
        clearTimeout(targetDebounceTimer);
        const value = e.target.value;
        targetDebounceTimer = setTimeout(() => {
          showAutocomplete(targetInput, targetDropdown, value);
          handleInputActivity();
        }, 150);
      });

      sourceInput.addEventListener('focus', (e) => {
        showAutocomplete(sourceInput, sourceDropdown, e.target.value);
        handleInputActivity();
      });

      targetInput.addEventListener('focus', (e) => {
        showAutocomplete(targetInput, targetDropdown, e.target.value);
        handleInputActivity();
      });
      
      sourceInput.addEventListener('change', handleInputActivity);
      targetInput.addEventListener('change', handleInputActivity);

      if(fromParam || toParam) handleInputActivity();

      // --- Autocomplete Logic ---
      let previousFiltered = [];
      const abbrListLower = {};
      for (const key in abbrList) {
        abbrListLower[key] = abbrList[key].toLowerCase();
      }

      function showAutocomplete(input, dropdown, value) {
        // For source input, get the last term after comma
        let searchTerm = value.toLowerCase().trim();
        
        if (input === sourceInput && searchTerm.includes(',')) {
          const terms = searchTerm.split(',');
          searchTerm = terms[terms.length - 1].trim();
        }
        
        if (!searchTerm) {
          dropdown.style.display = 'none';
          return;
        }

        const filtered = [];
        for (let i = 0; i < allTrackers.length; i++) {
          const tracker = allTrackers[i];
          const trackerLower = allTrackersLower[i];
          const abbrLower = abbrListLower[tracker] || '';
          if (trackerLower.includes(searchTerm) || abbrLower.includes(searchTerm)) {
            filtered.push(tracker);
          }
        }

        filtered.sort((a, b) => {
          const aLower = a.toLowerCase();
          const bLower = b.toLowerCase();
          const aStarts = aLower.startsWith(searchTerm) ? 0 : 1;
          const bStarts = bLower.startsWith(searchTerm) ? 0 : 1;
          if (aStarts !== bStarts) return aStarts - bStarts;
          return aLower.localeCompare(bLower);
        });

        const limited = filtered.slice(0, 20);

        const isSame = limited.length === previousFiltered.length &&
          limited.every((t, i) => t === previousFiltered[i]);
        if (isSame) return;
        previousFiltered = limited.slice();

        dropdown.innerHTML = '';

        limited.forEach(tracker => {
          const item = document.createElement('div');
          item.className = 'autocomplete-item';
          const abbr = abbrList[tracker] ? ` (${abbrList[tracker]})` : '';
          const nameHTML = tracker.replace(new RegExp(`(${searchTerm})`, 'ig'), '<mark>$1</mark>');
          const abbrHTML = abbr.replace(new RegExp(`(${searchTerm})`, 'ig'), '<mark>$1</mark>');

          item.innerHTML = nameHTML + abbrHTML;

          item.addEventListener('click', () => {
            if (input === sourceInput) {
              // For source, append to comma-separated list
              const currentValue = input.value;
              const terms = currentValue.split(',').map(t => t.trim());
              terms[terms.length - 1] = tracker;
              input.value = terms.join(', ');
            } else {
              input.value = tracker;
            }
            dropdown.style.display = 'none';
            calculateRoute();
            handleInputActivity();
            calculateRoute();
            updateURL();
          });
          dropdown.appendChild(item);
        });

        dropdown.style.display = limited.length > 0 ? 'block' : 'none';
      }

      // --- Update Time ---
      const apiUrl = `https://api.github.com/repos/x4714/private-tracker-route-planner/commits?path=trackers.json`;
      fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
          const commitDate = data[0].commit.committer.date;
          const updateDate = new Date(commitDate).toLocaleDateString();
          document.getElementById('update-time').innerText = `Updated ${updateDate}`;
        })
        .catch(error => {
          document.getElementById('update-time').innerText = ''; 
        });

      // --- Settings Logic ---
      function setMaxJumps(value) {
        maxJumpsInput.value = value;
        let matched = false;
        maxJumpsRadios.forEach(r => {
          r.checked = r.value == value;
          if (r.checked) matched = true;
        });
        if (!matched) maxJumpsRadios.forEach(r => r.checked = false);
        localStorage.setItem('maxJumps', value);
        calculateRoute();
        updateURL();
      }

      maxJumpsRadios.forEach(radio => {
        radio.addEventListener('change', () => setMaxJumps(parseInt(radio.value, 10)));
      });
      maxJumpsInput.addEventListener('change', () => {
        let val = parseInt(maxJumpsInput.value, 10);
        if (isNaN(val) || val < 1) val = 1;
        setMaxJumps(val);
      });
      setMaxJumps(maxJumps);

      function setMaxDays(value) {
        maxDaysInput.value = value;
        let matched = false;
        maxDaysRadios.forEach(r => {
          r.checked = r.value == value;
          if (r.checked) matched = true;
        });
        if (!matched) maxDaysRadios.forEach(r => r.checked = false);
        localStorage.setItem('maxDays', value);
        calculateRoute();
        updateURL();
      }

      maxDaysRadios.forEach(radio => {
        radio.addEventListener('change', () => setMaxDays(parseInt(radio.value, 10)));
      });
      maxDaysInput.addEventListener('change', () => {
        let val = parseInt(maxDaysInput.value, 10);
        if (isNaN(val) || val < 1) val = 1;
        setMaxDays(val);
      });
      setMaxDays(maxDays);

      function setSortOption(value) {
        sortRadios.forEach(r => r.checked = r.value === value);
        localStorage.setItem('sortOption', value);
        calculateRoute();
      }
      sortRadios.forEach(radio => {
        radio.addEventListener('change', () => setSortOption(radio.value));
      });
      setSortOption(sortOptionValue);

      // --- Route Calculation & Rendering ---

      function calculateRoute() {
        const routesGrid = document.getElementById('routesGrid');
        const fragment = document.createDocumentFragment();

        routesGrid.innerHTML = '';

        const startRaw = sourceInput.value.trim();
        const endRaw = targetInput.value.trim();

        // Parse source inputs (comma-separated)
        const sourceInputs = startRaw ? startRaw.split(',').map(s => s.trim()).filter(s => s) : [];
        const end = endRaw;

        if (sourceInputs.length === 0 && !end) {
          resultsInfo.innerHTML = '';
          body.classList.remove('has-results');
          return;
        }

        if (sourceInputs.length === 1 && end && sourceInputs[0] === end) {
          resultsInfo.innerHTML = 'One account per lifetime!';
          body.classList.add('has-results');
          return;
        }

        // Determine start nodes based on source inputs
        let startNodes = [];
        const allTrackerKeys = Object.keys(routeInfo);

        if (sourceInputs.length > 0) {
          // Filter trackers based on input (strict or fuzzy match)
          startNodes = allTrackerKeys.filter(tracker => {
            const trackerLower = tracker.toLowerCase();
            const trackerAbbr = getAbbr(tracker).toLowerCase();
            
            return sourceInputs.some(input => {
              const inputLower = input.toLowerCase();
              
              // Check if input is an exact match to any valid tracker
              const isStrictInput = allTrackers.some(validT => 
                validT.toLowerCase() === inputLower || 
                getAbbr(validT).toLowerCase() === inputLower
              );
              
              if (isStrictInput) {
                // Exact match required
                return trackerLower === inputLower || trackerAbbr === inputLower;
              } else {
                // Fuzzy match
                return trackerLower.includes(inputLower) || trackerAbbr === inputLower;
              }
            });
          });
        } else if (end) {
          // No source specified - search from ALL trackers
          startNodes = allTrackerKeys;
        }

        if (startNodes.length === 0 && sourceInputs.length > 0) {
          resultsInfo.innerHTML = `No trackers found matching: ${sourceInputs.join(', ')}`;
          body.classList.add('has-results');
          return;
        }

        // Check if target is strict match
        const isStrictTarget = end && allTrackers.some(t => 
          t.toLowerCase() === end.toLowerCase() || 
          getAbbr(t).toLowerCase() === end.toLowerCase()
        );

        // Find all routes using BFS
        let allRoutes = [];
        const startNodeSet = new Set(startNodes);
        const queue = [];

        // Initialize queue with all start nodes
        startNodes.forEach(start => {
          queue.push({
            source: start,
            current: start,
            path: [start],
            totalDays: 0
          });
        });

        while (queue.length > 0) {
          const { source, current, path, totalDays } = queue.shift();

          // Check if we've reached the target (if specified)
          if (path.length > 1) {
            let isTargetMatch = true;
            
            if (end) {
              const currentLower = current.toLowerCase();
              const currentAbbr = getAbbr(current).toLowerCase();
              const endLower = end.toLowerCase();
              
              if (isStrictTarget) {
                isTargetMatch = currentLower === endLower || currentAbbr === endLower;
              } else {
                isTargetMatch = currentLower.includes(endLower) || currentAbbr.includes(endLower);
              }
            }
            
            if (isTargetMatch) {
              if (totalDays <= maxDays) {
                allRoutes.push({
                  source,
                  target: current,
                  path,
                  totalDays
                });
              }
            }
          }

          // Stop if we've reached max jumps
          if (path.length > maxJumps) continue;

          // Explore neighbors
          const neighbors = routeInfo[current];
          if (neighbors) {
            Object.entries(neighbors).forEach(([nextTracker, details]) => {
              // Don't revisit start nodes (unless it's the target)
              if (startNodeSet.has(nextTracker) && nextTracker.toLowerCase() !== end?.toLowerCase()) {
                return;
              }

              // Don't revisit nodes in current path
              if (!path.includes(nextTracker)) {
                const edgeDays = details.days;
                const forumReq = unlockInviteClass[current];
                const forumDays = forumReq ? forumReq[0] : 0;
                
                let stepDays = null;
                if (edgeDays !== null) {
                  stepDays = Math.max(edgeDays, forumDays || 0);
                }
                
                const nextTotalDays = (totalDays === null || stepDays === null) 
                  ? totalDays // Preserve null or current value
                  : totalDays + stepDays;
                
                if (maxDays !== null && nextTotalDays !== null && nextTotalDays > maxDays) return;

                queue.push({
                  source,
                  current: nextTracker,
                  path: [...path, nextTracker],
                  totalDays: nextTotalDays
                });
              }
            });
          }
        }

        // Remove duplicates using a Set with path signature
        const uniqueRoutes = [];
        const seenPaths = new Set();
        
        allRoutes.forEach(route => {
          const pathSignature = route.path.join('->');
          if (!seenPaths.has(pathSignature)) {
            seenPaths.add(pathSignature);
            uniqueRoutes.push(route);
          }
        });

        allRoutes = uniqueRoutes;

        if (allRoutes.length === 0) {
          resultsInfo.innerHTML = 'No routes found';
          body.classList.add('has-results');
          return;
        }

        // Sorting
        let selectedSort = 'fastest';
        sortRadios.forEach(r => {
          if (r.checked) selectedSort = r.value;
        });

        if (selectedSort === 'fastest') {
          allRoutes.sort((a, b) => {
            if (a.totalDays !== b.totalDays) return a.totalDays - b.totalDays;
            return a.path.length - b.path.length;
          });
        } else if (selectedSort === 'fewestJumps') {
          allRoutes.sort((a, b) => {
            if (a.path.length !== b.path.length) return a.path.length - b.path.length;
            return a.totalDays - b.totalDays;
          });
        }

        resultsInfo.innerHTML = `Found ${allRoutes.length} route${allRoutes.length !== 1 ? 's' : ''}`;
        body.classList.add('has-results');

        allRoutes.forEach((route, index) => {
          fragment.appendChild(createRouteCard(route, index + 1));
        });
        routesGrid.appendChild(fragment);
      }

      function createRouteCard(route, routeNumber) {
        const card = document.createElement('div');
        card.className = 'route-card';

        const abbreviatedRoute = route.path.map(node => abbrList[node] || node);
        const displayRoute = abbreviatedRoute.join(' → ');

        const totalDays = route.totalDays;
        const jumps = route.path.length - 1;

        let stepsHTML = '';
        route.path.forEach((node, index) => {
          if (index < route.path.length - 1 && routeInfo[node] && routeInfo[node][route.path[index + 1]]) {
            const nextNode = route.path[index + 1];
            const maxDaysValue = getMaxDays(node, nextNode);
            const routeData = routeInfo[node][nextNode];
            const requirement = routeData.reqs || '';
            const lastActivity = routeData.updated || 'Unknown';
            const activeStatus = routeData.active || 'Unknown';

            let statusClass = 'status-unknown';
            if (activeStatus.toLowerCase() === 'yes') statusClass = 'status-recruiting';
            if (activeStatus.toLowerCase() === 'no') statusClass = 'status-closed';

            const statusText = activeStatus === 'Yes' ? 'Recruiting' : (activeStatus === 'No' ? 'Closed' : 'Unknown');
            const daysDisplay = maxDaysValue === null ? 'Unknown' : `${maxDaysValue}d`;

            let detailsHTML = '';
            
            const className = unlockInviteClass[node] ? unlockInviteClass[node][1] : 'N/A';
            detailsHTML += `
              <div class="route-step-detail">
                <div class="route-step-label">Class needed:</div>
                <div class="route-step-value">${className}</div>
              </div>
            `;

            if (requirement && requirement.toLowerCase() !== 'none' && requirement.toLowerCase() !== 'no requirement') {
               detailsHTML += `
                <div class="route-step-detail">
                  <div class="route-step-label">Requirements:</div>
                  <div class="route-step-value">${requirement}</div>
                </div>
              `;
            }

            stepsHTML += `
              <div class="route-step">
                <div class="route-step-header">
                  <div class="step-connection">
                    <span>${node} → ${nextNode}</span>
                    <span class="route-step-days">${daysDisplay}</span>
                  </div>
                  <div class="step-meta-right">
                    <span class="status-badge ${statusClass}">${statusText}</span>
                    <span class="last-checked">Checked: ${lastActivity}</span>
                  </div>
                </div>
                ${detailsHTML}
              </div>
            `;
          }
        });

        card.innerHTML = `
          <div class="route-header">${displayRoute}</div>
          <div class="route-summary">
            <span>Route #${routeNumber}</span>
            <span>${jumps} jump${jumps !== 1 ? 's' : ''} · ${totalDays !== null ? totalDays + ' days' : 'Unknown days'}</span>
          </div>
          ${stepsHTML}
        `;

        return card;
      }

      function getMaxDays(start, end) {
        const routeData = routeInfo[start] && routeInfo[start][end];
        const days1 = routeData && routeData.days !== undefined ? routeData.days : null;
        const days2 = (unlockInviteClass[start] && unlockInviteClass[start][0]) || 0;

        if (days1 === null) return null;

        return Math.max(days1, days2);
      }

      function updateURL() {
        const params = new URLSearchParams();
        if (sourceInput.value) params.set('from', sourceInput.value);
        if (targetInput.value) params.set('to', targetInput.value);
        params.set('jumps', maxJumps);
        params.set('days', maxDays);
        const selectedSort = Array.from(sortRadios).find(r => r.checked)?.value || 'fastest';
        params.set('sort', selectedSort);
        history.replaceState(null, '', '?' + params.toString());
      }
    });
  </script>
</body>


</html>

