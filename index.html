<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TrackersInfo Official Recruitments</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="styles.css" rel="stylesheet" />
</head>
<body>
  <div id="routeContainer">
    <div id="settingsMenu">
      <div class="setting">
        <label>Max Jumps</label>
        <div class="radio-group" id="maxJumpsRadios">
          <label><input type="radio" name="maxJumps" value="1"> 1</label>
          <label><input type="radio" name="maxJumps" value="2"> 2</label>
          <label><input type="radio" name="maxJumps" value="3"> 3</label>
          <label><input type="radio" name="maxJumps" value="4"> 4</label>
          <label><input type="radio" name="maxJumps" value="5"> 5</label>
        </div>
        <input type="number" id="maxJumpsInput" value="5" min="1" style="margin-top:6px;">
      </div>
    
      <div class="setting">
        <label>Max Days</label>
        <div class="radio-group" id="maxDaysRadios">
          <label><input type="radio" name="maxDays" value="180">6m</label>
          <label><input type="radio" name="maxDays" value="360">1y</label>
          <label><input type="radio" name="maxDays" value="720">2y</label>
          <label><input type="radio" name="maxDays" value="1800">5y</label>
          <label><input type="radio" name="maxDays" value="3600">10y</label>
        </div>
        <input type="number" id="maxDaysInput" value="1080" min="1" style="margin-top:6px;">
      </div>
    
      <div class="setting">
        <label>Sort By</label>
        <div class="radio-group" id="sortRadios">
          <label><input type="radio" name="sortOption" value="fastest">Fastest Route</label>
          <label><input type="radio" name="sortOption" value="fewestJumps">Least Jumps</label>
        </div>
      </div>
    </div>
    
    <div id="calcForm">
      <div id="headerSection">
        <div class="input-group">
          <label class="input-label">From</label>
          <input type="text" class="tracker-input" id="sourceInput" placeholder="Any tracker">
          <div id="sourceDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
        
        <div class="arrow-separator">→</div>
        
        <div class="input-group">
          <label class="input-label">To</label>
          <input type="text" class="tracker-input" id="targetInput" placeholder="Any tracker">
          <div id="targetDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
      </div>
      
      <div id="resultsInfo"></div>
      <div id="routesGrid"></div>
    </div>
  </div>
  
  <div class="footer-info">
    <span id="update-time">Loading...</span>
    <a href="https://www.reddit.com/r/TrackersInfo/wiki/official_recruitments/">TrackersInfo</a>
    <a href="https://github.com/ti-or/ti-or.github.io">GitHub</a>
  </div>

  <script>
    window.addEventListener('load', async function() {
      let data;
      try {
        const response = await fetch('trackers.json');
        data = await response.json();
      } catch (error) {
        console.error('Error loading trackers.json:', error);
        return;
      }

      const settingsMenu = document.getElementById('settingsMenu');
      const maxJumpsInput = document.getElementById('maxJumps');
      const maxDaysInput = document.getElementById('maxDays');
      const sortOption = document.getElementById('sortOption');
      const settingsToggle = document.getElementById('settingsToggle');
      const sourceInput = document.getElementById('sourceInput');
      const targetInput = document.getElementById('targetInput');
      const sourceDropdown = document.getElementById('sourceDropdown');
      const targetDropdown = document.getElementById('targetDropdown');      
      const maxJumpsInput = document.getElementById('maxJumpsInput');
      const maxJumpsRadios = document.querySelectorAll('#maxJumpsRadios input');
      
      let maxJumps = parseInt(localStorage.getItem('maxJumps'), 10) || 5;
      let maxDays = parseInt(localStorage.getItem('maxDays'), 10) || 1080;
      let sortOptionValue = localStorage.getItem('sortOption') || 'fastest';

      let sourceDebounceTimer;
      let targetDebounceTimer;
      
      maxJumpsInput.value = maxJumps;
      maxDaysInput.value = maxDays;
      sortOption.value = sortOptionValue;

      const { routeInfo, unlockInviteClass, abbrList } = data;

      const allTrackers = Array.from(new Set(
        Object.keys(routeInfo)
        .flatMap(startKey => [startKey, ...Object.keys(routeInfo[startKey])])
      )).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

      const allTrackersLower = allTrackers.map(t => t.toLowerCase());

      maxJumpsInput.addEventListener('change', (event) => {
        maxJumps = parseInt(event.target.value, 10);
        localStorage.setItem('maxJumps', maxJumps);
        calculateRoute();
      });

      maxDaysInput.addEventListener('change', (event) => {
        maxDays = parseInt(event.target.value, 10);
        localStorage.setItem('maxDays', maxDays);
        calculateRoute();
      });

      sortOption.addEventListener('change', () => {
        localStorage.setItem('sortOption', sortOption.value);
        calculateRoute();
      });
      
      settingsToggle.addEventListener('click', (event) => {
        event.stopPropagation();
        settingsMenu.style.display = settingsMenu.style.display === 'block' ? 'none' : 'block';
      });

      document.addEventListener('mousedown', (event) => {
        if (!settingsMenu.contains(event.target) && event.target !== settingsToggle) {
          settingsMenu.style.display = 'none';
        }
      
        if (
          !sourceDropdown.contains(event.target) &&
          !sourceInput.contains(event.target)
        ) {
          sourceDropdown.style.display = 'none';
        }
      
        if (
          !targetDropdown.contains(event.target) &&
          !targetInput.contains(event.target)
        ) {
          targetDropdown.style.display = 'none';
        }
      });

      [sourceDropdown, targetDropdown].forEach(dropdown => {
        dropdown.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
      });
      
      [sourceInput, targetInput].forEach(input => {
        input.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
      });

      sourceInput.addEventListener('focus', (e) => {
        showAutocomplete(sourceInput, sourceDropdown, e.target.value);
      });

      sourceInput.addEventListener('input', (e) => {
        clearTimeout(sourceDebounceTimer);
        const value = e.target.value;
        sourceDebounceTimer = setTimeout(() => {
          showAutocomplete(sourceInput, sourceDropdown, value);
        }, 150);
      });
      
      targetInput.addEventListener('input', (e) => {
        clearTimeout(targetDebounceTimer);
        const value = e.target.value;
        targetDebounceTimer = setTimeout(() => {
          showAutocomplete(targetInput, targetDropdown, value);
        }, 150);
      });

      targetInput.addEventListener('focus', (e) => {
        showAutocomplete(targetInput, targetDropdown, e.target.value);
      });

      let previousFiltered = [];
      const abbrListLower = {};
      for (const key in abbrList) {
        abbrListLower[key] = abbrList[key].toLowerCase();
      }
      
      function showAutocomplete(input, dropdown, value) {
        const searchTerm = value.toLowerCase().trim();
        if (!searchTerm) {
          dropdown.style.display = 'none';
          return;
        }

        const filtered = [];
        for (let i = 0; i < allTrackers.length; i++) {
          const tracker = allTrackers[i];
          const trackerLower = allTrackersLower[i];
          const abbrLower = abbrListLower[tracker] || '';
          if (trackerLower.includes(searchTerm) || abbrLower.includes(searchTerm)) {
            filtered.push(tracker);
            if (filtered.length >= 20) break;
          }
        }

        const isSame = filtered.length === previousFiltered.length &&
                       filtered.every((t, i) => t === previousFiltered[i] &&
                         ((abbrList[t] || '') === (abbrList[previousFiltered[i]] || '')));
        if (isSame) return;
        previousFiltered = filtered.slice();
      
        dropdown.innerHTML = '';

        filtered.forEach(tracker => {
          const item = document.createElement('div');
          item.className = 'autocomplete-item';
      
          const abbr = abbrList[tracker] ? ` (${abbrList[tracker]})` : '';

          const nameHTML = tracker.replace(new RegExp(`(${searchTerm})`, 'ig'), '<mark>$1</mark>');
          const abbrHTML = abbr.replace(new RegExp(`(${searchTerm})`, 'ig'), '<mark>$1</mark>');
      
          item.innerHTML = nameHTML + abbrHTML;
      
          item.addEventListener('click', () => {
            input.value = tracker;
            dropdown.style.display = 'none';
            calculateRoute();
          });
      
          dropdown.appendChild(item);
        });
      
        dropdown.style.display = filtered.length > 0 ? 'block' : 'none';
      }

      const apiUrl = `https://api.github.com/repos/x4714/private-tracker-route-planner/commits?path=trackers.json`;

      fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
          const commitDate = data[0].commit.committer.date;
          const updateDate = new Date(commitDate).toLocaleDateString();
          document.getElementById('update-time').innerText = `Updated ${updateDate}`;
        })
        .catch(error => {
          console.error('Error fetching commit data:', error);
          document.getElementById('update-time').innerText = 'Update date unavailable';
        });

      function setMaxJumps(value) {
        maxJumpsInput.value = value;
        maxJumpsRadios.forEach(r => r.checked = r.value === value.toString());
        localStorage.setItem('maxJumps', value);
        calculateRoute();
      }

      maxJumpsRadios.forEach(radio => {
        radio.addEventListener('change', () => setMaxJumps(parseInt(radio.value,10)));
      });
      
      maxJumpsInput.addEventListener('change', () => {
        let val = parseInt(maxJumpsInput.value,10);
        if (isNaN(val) || val < 1) val = 1;
        setMaxJumps(val);
      });
      
      setMaxJumps(parseInt(localStorage.getItem('maxJumps'),10) || 5);
      
      const maxDaysInput = document.getElementById('maxDaysInput');
      const maxDaysRadios = document.querySelectorAll('#maxDaysRadios input');
      
      function setMaxDays(value) {
        maxDaysInput.value = value;
        maxDaysRadios.forEach(r => r.checked = r.value === value.toString());
        localStorage.setItem('maxDays', value);
        calculateRoute();
      }
      
      maxDaysRadios.forEach(radio => {
        radio.addEventListener('change', () => setMaxDays(parseInt(radio.value,10)));
      });
      
      maxDaysInput.addEventListener('change', () => {
        let val = parseInt(maxDaysInput.value,10);
        if (isNaN(val) || val < 1) val = 1;
        setMaxDays(val);
      });
      
      setMaxDays(parseInt(localStorage.getItem('maxDays'),10) || 1080);
      
      const sortRadios = document.querySelectorAll('#sortRadios input');
      
      function setSortOption(value) {
        sortRadios.forEach(r => r.checked = r.value === value);
        localStorage.setItem('sortOption', value);
        calculateRoute();
      }
      
      sortRadios.forEach(radio => {
        radio.addEventListener('change', () => setSortOption(radio.value));
      });
      
      setSortOption(localStorage.getItem('sortOption') || 'fastest');

      function calculateRoute() {
        const resultsInfo = document.getElementById('resultsInfo');
        const routesGrid = document.getElementById('routesGrid');
        const fragment = document.createDocumentFragment();

        resultsInfo.innerHTML = '';
        routesGrid.innerHTML = '';

        const start = sourceInput.value.trim();
        const end = targetInput.value.trim();

        if (!start && !end) {
          resultsInfo.innerHTML = 'Enter source and/or target tracker to find routes';
          return;
        }

        if (start && end && start === end) {
          resultsInfo.innerHTML = 'One account per lifetime!';
          return;
        }

        let allRoutes = [];

        if (!start || start === '') {
          if (end && routeInfo[end]) {
            resultsInfo.innerHTML = 'Please enter a source tracker';
            return;
          }
          allRoutes = Object.keys(routeInfo)
            .filter(node => routeInfo[node] && routeInfo[node][end])
            .map(node => [node, end]);
        } else if (!end || end === '') {
          if (!routeInfo[start]) {
            resultsInfo.innerHTML = `No official recruitment from ${start}`;
            return;
          }
          allRoutes = Object.keys(routeInfo[start])
            .map(node => [start, node])
            .filter(([from, to]) => routeInfo[from] && routeInfo[from][to]);
        } else {
          if (!routeInfo[start]) {
            resultsInfo.innerHTML = `No official recruitment from ${start}`;
            return;
          }
          allRoutes = findAllRoutes(start, end, maxJumps, maxDays);
        }

        if (allRoutes.length === 0) {
          resultsInfo.innerHTML = 'No routes found';
          return;
        }

        if (sortOption.value === 'fastest') {
          allRoutes = allRoutes.sort((a, b) => {
            const timeA = calculateRouteDays(a);
            const timeB = calculateRouteDays(b);
            if (timeA !== timeB) return timeA - timeB;
            return a.length - b.length;
          });
        } else if (sortOption.value === 'fewestJumps') {
          allRoutes = allRoutes.sort((a, b) => {
            if (a.length !== b.length) return a.length - b.length;
            return calculateRouteDays(a) - calculateRouteDays(b);
          });
        }

        resultsInfo.innerHTML = `Found ${allRoutes.length} route${allRoutes.length !== 1 ? 's' : ''}`;

        allRoutes.forEach((route, index) => {
          fragment.appendChild(createRouteCard(route, index + 1));
        });
        routesGrid.appendChild(fragment);
      }

      function createRouteCard(route, routeNumber) {
        const card = document.createElement('div');
        card.className = 'route-card';

        const abbreviatedRoute = route.map(node => abbrList[node] || node);
        const displayRoute = abbreviatedRoute.join(' → ');

        const totalDays = calculateRouteDays(route);
        const jumps = route.length - 1;

        let stepsHTML = '';
        route.forEach((node, index) => {
          if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
            const nextNode = route[index + 1];
            const maxDays = getMaxDays(node, nextNode);
            const routeData = routeInfo[node][nextNode];
            const requirement = routeData.reqs || 'No requirement';
            const lastActivity = routeData.updated || 'Unknown';
            const daysDisplay = maxDays === null ? 'Unknown' : `${maxDays}d`;

            stepsHTML += `
              <div class="route-step">
                <div class="route-step-header">
                  <span>${node} → ${nextNode}</span>
                  <span class="route-step-days">${daysDisplay}</span>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Class needed:</div>
                  <div class="route-step-value">${unlockInviteClass[node] ? unlockInviteClass[node][1] : 'N/A'}</div>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Requirements:</div>
                  <div class="route-step-value">${requirement}</div>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Last checked:</div>
                  <div class="route-step-value">${lastActivity}</div>
                </div>
              </div>
            `;
          }
        });

        card.innerHTML = `
          <div class="route-header">${displayRoute}</div>
          <div class="route-summary">
            <span>Route #${routeNumber}</span>
            <span>${jumps} jump${jumps !== 1 ? 's' : ''} · ${totalDays} days</span>
          </div>
          ${stepsHTML}
        `;

        return card;
      }

      function calculateRouteDays(route) {
        return route.reduce((sum, node, index) => {
          if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
            const days = getMaxDays(node, route[index + 1]);
            return sum + (days === null ? 0 : days);
          }
          return sum;
        }, 0);
      }

      function findAllRoutes(start, end, maxJumps = 5, maxDays = 1080) {
        const result = [];
        const stack = [[start, [start], 0]];
      
        while (stack.length) {
          const [node, route, days] = stack.pop();
      
          if (route.length > maxJumps + 1) continue;
          if (days > maxDays) continue; // early cutoff
      
          if (node === end) {
            result.push(route);
            continue;
          }
      
          const neighbors = Object.entries(routeInfo[node] || {});
          for (const [next, _] of neighbors) {
            if (!route.includes(next)) {
              const maxDaysToNext = getMaxDays(node, next);
              const newDays = (maxDaysToNext === null ? days : days + maxDaysToNext);
              stack.push([next, [...route, next], newDays]);
            }
          }
        }
      
        return result;
      }

      function getMaxDays(start, end) {
        const routeData = routeInfo[start] && routeInfo[start][end];
        const days1 = routeData && routeData.days !== undefined ? routeData.days : null;
        const days2 = (unlockInviteClass[start] && unlockInviteClass[start][0]) || 0;

        if (days1 === null) return null;
        
        return Math.max(days1, days2);
      }

      // Initial calculation
      calculateRoute();

      window.addEventListener('error', (e) => {
        console.error('JS Error:', e.message, e.filename, e.lineno);
      });

    });
  </script>
</body>
</html>




