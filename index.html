<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TrackersInfo Official Recruitments</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="styles.css" rel="stylesheet" />
</head>
<body>
  <button id="settingsToggle" aria-label="Settings" title="Settings">⚙</button>
  <div id="routeContainer">
    <div id="settingsMenu">
      <div class="setting">
        <label for="maxJumps">Max Jumps</label>
        <input type="number" id="maxJumps" value="5" min="1">
      </div>
      
      <div class="setting">
        <label for="maxDays">Max Days</label>
        <input type="number" id="maxDays" value="1080" min="1">
      </div>
      
      <div class="setting">
        <label for="sortOption">Sort By</label>
        <select id="sortOption">
          <option value="fastest">Fastest Route</option>
          <option value="fewestJumps">Least Jumps</option>
        </select>
      </div>
    </div>
    
    <div id="calcForm">
      <div id="headerSection">
        <div class="input-group">
          <label class="input-label">From</label>
          <input type="text" class="tracker-input" id="sourceInput" placeholder="Any tracker">
          <div id="sourceDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
        
        <div class="arrow-separator">→</div>
        
        <div class="input-group">
          <label class="input-label">To</label>
          <input type="text" class="tracker-input" id="targetInput" placeholder="Any tracker">
          <div id="targetDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
      </div>
      
      <div id="resultsInfo"></div>
      <div id="routesGrid"></div>
    </div>
  </div>
  
  <div class="footer-info">
    <span id="update-time">Loading...</span>
    <a href="https://www.reddit.com/r/TrackersInfo/wiki/official_recruitments/">TrackersInfo</a>
    <a href="https://github.com/ti-or/ti-or.github.io">GitHub</a>
  </div>

  <script>
    window.addEventListener('load', async function() {
      let data;
      try {
        const response = await fetch('trackers.json');
        data = await response.json();
      } catch (error) {
        console.error('Error loading trackers.json:', error);
        return;
      }

      const settingsMenu = document.getElementById('settingsMenu');
      const maxJumpsInput = document.getElementById('maxJumps');
      const maxDaysInput = document.getElementById('maxDays');
      const sortOption = document.getElementById('sortOption');
      const settingsToggle = document.getElementById('settingsToggle');
      const sourceInput = document.getElementById('sourceInput');
      const targetInput = document.getElementById('targetInput');
      const sourceDropdown = document.getElementById('sourceDropdown');
      const targetDropdown = document.getElementById('targetDropdown');
      
      let maxJumps = parseInt(localStorage.getItem('maxJumps'), 10) || 5;
      let maxDays = parseInt(localStorage.getItem('maxDays'), 10) || 1080;
      let sortOptionValue = localStorage.getItem('sortOption') || 'fastest';

      maxJumpsInput.value = maxJumps;
      maxDaysInput.value = maxDays;
      sortOption.value = sortOptionValue;

      const { routeInfo, unlockInviteClass, abbrList } = data;

      const allTrackers = Array.from(new Set(
        Object.keys(routeInfo)
        .flatMap(startKey => [startKey, ...Object.keys(routeInfo[startKey])])
      )).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

      maxJumpsInput.addEventListener('change', (event) => {
        maxJumps = parseInt(event.target.value, 10);
        localStorage.setItem('maxJumps', maxJumps);
        calculateRoute();
      });

      maxDaysInput.addEventListener('change', (event) => {
        maxDays = parseInt(event.target.value, 10);
        localStorage.setItem('maxDays', maxDays);
        calculateRoute();
      });

      sortOption.addEventListener('change', () => {
        localStorage.setItem('sortOption', sortOption.value);
        calculateRoute();
      });
      
      settingsToggle.addEventListener('click', (event) => {
        event.stopPropagation();
        settingsMenu.style.display = settingsMenu.style.display === 'block' ? 'none' : 'block';
      });

      document.addEventListener('click', (event) => {
        if (!settingsMenu.contains(event.target) && event.target !== settingsToggle) {
          settingsMenu.style.display = 'none';
        }
        if (!sourceDropdown.contains(event.target) && event.target !== sourceInput) {
          sourceDropdown.style.display = 'none';
        }
        if (!targetDropdown.contains(event.target) && event.target !== targetInput) {
          targetDropdown.style.display = 'none';
        }
      });

      sourceInput.addEventListener('input', (e) => {
        showAutocomplete(sourceInput, sourceDropdown, e.target.value);
        calculateRoute();
      });

      targetInput.addEventListener('input', (e) => {
        showAutocomplete(targetInput, targetDropdown, e.target.value);
        calculateRoute();
      });

      sourceInput.addEventListener('focus', (e) => {
        showAutocomplete(sourceInput, sourceDropdown, e.target.value);
      });

      targetInput.addEventListener('focus', (e) => {
        showAutocomplete(targetInput, targetDropdown, e.target.value);
      });

      function showAutocomplete(input, dropdown, value) {
        const searchTerm = value.toLowerCase().trim();
        
        let filtered = allTrackers;
        if (searchTerm) {
          filtered = allTrackers.filter(tracker => 
            tracker.toLowerCase().includes(searchTerm) ||
            (abbrList[tracker] && abbrList[tracker].toLowerCase().includes(searchTerm))
          );
        }

        if (filtered.length === 0 && searchTerm) {
          dropdown.style.display = 'none';
          return;
        }

        dropdown.innerHTML = '';
        filtered.slice(0, 20).forEach(tracker => {
          const item = document.createElement('div');
          item.className = 'autocomplete-item';
          const abbr = abbrList[tracker] ? ` (${abbrList[tracker]})` : '';
          item.textContent = tracker + abbr;
          item.addEventListener('click', () => {
            input.value = tracker;
            dropdown.style.display = 'none';
            calculateRoute();
          });
          dropdown.appendChild(item);
        });

        dropdown.style.display = filtered.length > 0 ? 'block' : 'none';
      }

      const apiUrl = `https://api.github.com/repos/x4714/private-tracker-route-planner/commits?path=trackers.json`;

      fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
          const commitDate = data[0].commit.committer.date;
          const updateDate = new Date(commitDate).toLocaleDateString();
          document.getElementById('update-time').innerText = `Updated ${updateDate}`;
        })
        .catch(error => {
          console.error('Error fetching commit data:', error);
          document.getElementById('update-time').innerText = 'Update date unavailable';
        });

      function calculateRoute() {
        const resultsInfo = document.getElementById('resultsInfo');
        const routesGrid = document.getElementById('routesGrid');

        resultsInfo.innerHTML = '';
        routesGrid.innerHTML = '';

        const start = sourceInput.value.trim();
        const end = targetInput.value.trim();

        if (!start && !end) {
          resultsInfo.innerHTML = 'Enter source and/or target tracker to find routes';
          return;
        }

        if (start && end && start === end) {
          resultsInfo.innerHTML = 'One account per lifetime!';
          return;
        }

        let allRoutes = [];

        if (!start || start === '') {
          if (end && routeInfo[end]) {
            resultsInfo.innerHTML = 'Please enter a source tracker';
            return;
          }
          allRoutes = Object.keys(routeInfo)
            .filter(node => routeInfo[node] && routeInfo[node][end])
            .map(node => [node, end]);
        } else if (!end || end === '') {
          if (!routeInfo[start]) {
            resultsInfo.innerHTML = `No official recruitment from ${start}`;
            return;
          }
          allRoutes = Object.keys(routeInfo[start])
            .map(node => [start, node])
            .filter(([from, to]) => routeInfo[from] && routeInfo[from][to]);
        } else {
          if (!routeInfo[start]) {
            resultsInfo.innerHTML = `No official recruitment from ${start}`;
            return;
          }
          allRoutes = findAllRoutes(start, end, maxJumps, maxDays);
        }

        if (allRoutes.length === 0) {
          resultsInfo.innerHTML = 'No routes found';
          return;
        }

        if (sortOption.value === 'fastest') {
          allRoutes = allRoutes.sort((a, b) => {
            const timeA = calculateRouteDays(a);
            const timeB = calculateRouteDays(b);
            if (timeA !== timeB) return timeA - timeB;
            return a.length - b.length;
          });
        } else if (sortOption.value === 'fewestJumps') {
          allRoutes = allRoutes.sort((a, b) => {
            if (a.length !== b.length) return a.length - b.length;
            return calculateRouteDays(a) - calculateRouteDays(b);
          });
        }

        resultsInfo.innerHTML = `Found ${allRoutes.length} route${allRoutes.length !== 1 ? 's' : ''}`;

        allRoutes.forEach((route, index) => {
          routesGrid.appendChild(createRouteCard(route, index + 1));
        });
      }

      function createRouteCard(route, routeNumber) {
        const card = document.createElement('div');
        card.className = 'route-card';

        const abbreviatedRoute = route.map(node => abbrList[node] || node);
        const displayRoute = abbreviatedRoute.join(' → ');

        const totalDays = calculateRouteDays(route);
        const jumps = route.length - 1;

        let stepsHTML = '';
        route.forEach((node, index) => {
          if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
            const nextNode = route[index + 1];
            const maxDays = getMaxDays(node, nextNode);
            const routeData = routeInfo[node][nextNode];
            const requirement = routeData.reqs || 'No requirement';
            const lastActivity = routeData.updated || 'Unknown';
            const daysDisplay = maxDays === null ? 'Unknown' : `${maxDays}d`;

            stepsHTML += `
              <div class="route-step">
                <div class="route-step-header">
                  <span>${node} → ${nextNode}</span>
                  <span class="route-step-days">${daysDisplay}</span>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Class needed:</div>
                  <div class="route-step-value">${unlockInviteClass[node] ? unlockInviteClass[node][1] : 'N/A'}</div>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Requirements:</div>
                  <div class="route-step-value">${requirement}</div>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Last checked:</div>
                  <div class="route-step-value">${lastActivity}</div>
                </div>
              </div>
            `;
          }
        });

        card.innerHTML = `
          <div class="route-header">${displayRoute}</div>
          <div class="route-summary">
            <span>Route #${routeNumber}</span>
            <span>${jumps} jump${jumps !== 1 ? 's' : ''} · ${totalDays} days</span>
          </div>
          ${stepsHTML}
        `;

        return card;
      }

      function calculateRouteDays(route) {
        return route.reduce((sum, node, index) => {
          if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
            const days = getMaxDays(node, route[index + 1]);
            return sum + (days === null ? 0 : days);
          }
          return sum;
        }, 0);
      }

      function findAllRoutes(start, end, maxJumps = 5, maxDays = 1080) {
        const result = [];
        const stack = [[start, [start], 0]];

        while (stack.length) {
          const [node, route, days] = stack.pop();
          
          if (route.length > maxJumps + 1) continue;

          if (node === end) {
            result.push(route);
            continue;
          }

          for (const [next, _] of Object.entries(routeInfo[node] || {})) {
            if (!route.includes(next)) {
              const maxDaysToNext = getMaxDays(node, next);
              if (maxDaysToNext === null || maxDaysToNext === 0 || (days + maxDaysToNext) <= maxDays) {
                const newDays = maxDaysToNext === null ? days : days + maxDaysToNext;
                stack.push([next, [...route, next], newDays]);
              }
            }
          }
        }

        return result;
      }

      function getMaxDays(start, end) {
        const routeData = routeInfo[start] && routeInfo[start][end];
        const days1 = routeData && routeData.days !== undefined ? routeData.days : null;
        const days2 = (unlockInviteClass[start] && unlockInviteClass[start][0]) || 0;

        if (days1 === null) return null;
        
        return Math.max(days1, days2);
      }

      // Initial calculation
      calculateRoute();
    });
  </script>
</body>
</html>

