<!DOCTYPE html>
<html lang="en">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "Private Tracker Route Planner",
  "url": "https://x4714.github.io/private-tracker-route-planner/",
  "description": "Find the fastest and shortest routes between private trackers using TrackersInfo recruitment data.",
  "applicationCategory": "Utility",
  "operatingSystem": "All"
}
</script>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Private Tracker Route Planner</title>

  <meta name="description" content="Find the fastest and shortest routes between private trackers. Official TrackersInfo recruitment and route planner tool." />
  <meta name="keywords" content="private trackers, tracker route, trackersinfo, torrent trackers, tracker jumps" />
  <meta name="author" content="TrackersInfo" />

  <!-- Open Graph -->
  <meta property="og:title" content="Private Tracker Route Planner" />
  <meta property="og:description" content="Calculate optimal routes between private trackers using TrackersInfo data." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://github.com/x4714/private-tracker-route-planner" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Private Tracker Route Planner" />
  <meta name="twitter:description" content="Fastest and fewest-jumps tracker route calculator." />


  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="styles.css" rel="stylesheet" />
</head>
<body>
  <div id="routeContainer">
    <div id="settingsMenu">
      <div class="setting">
        <label>Max Jumps</label>
        <div class="radio-group" id="maxJumpsRadios">
          <label><input type="radio" name="maxJumps" value="1">1</label>
          <label><input type="radio" name="maxJumps" value="2">2</label>
          <label><input type="radio" name="maxJumps" value="3">3</label>
          <label><input type="radio" name="maxJumps" value="4">4</label>
          <label><input type="radio" name="maxJumps" value="5">5</label>
        </div>
        <input type="number" id="maxJumpsInput" value="5" min="1">
      </div>
    
      <div class="setting">
        <label>Max Days</label>
        <div class="radio-group" id="maxDaysRadios">
          <label><input type="radio" name="maxDays" value="180">6m</label>
          <label><input type="radio" name="maxDays" value="360">1y</label>
          <label><input type="radio" name="maxDays" value="720">2y</label>
          <label><input type="radio" name="maxDays" value="1800">5y</label>
          <label><input type="radio" name="maxDays" value="3600">10y</label>
        </div>
        <input type="number" id="maxDaysInput" value="1080" min="1">
      </div>
    
      <div class="setting">
        <label>Sort By</label>
        <div class="radio-group" id="sortRadios">
          <label><input type="radio" name="sortOption" value="fastest">Fastest</label>
          <label><input type="radio" name="sortOption" value="fewestJumps">Fewest Jumps</label>
        </div>
      </div>
    </div>
    
    <div id="calcForm">
      <div id="headerSection">
        <div class="input-group">
          <label class="input-label">From</label>
          <input type="text" class="tracker-input" id="sourceInput" placeholder="Any tracker">
          <div id="sourceDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
        
        <div class="arrow-separator">→</div>
        
        <div class="input-group">
          <label class="input-label">To</label>
          <input type="text" class="tracker-input" id="targetInput" placeholder="Any tracker">
          <div id="targetDropdown" class="autocomplete-dropdown" style="display: none;"></div>
        </div>
      </div>
      
      <div id="resultsInfo"></div>
      <div id="routesGrid"></div>
    </div>
  </div>
  
  <div class="footer-info">
    <span id="update-time">Loading...</span>
    <a href="https://www.reddit.com/r/TrackersInfo/wiki/official_recruitments/">TrackersInfo</a>
    <a href="https://github.com/x4714/private-tracker-route-planner">GitHub</a>
  </div>

  <script>
    window.addEventListener('load', async function() {
      let data;
      try {
        const response = await fetch('trackers.json');
        data = await response.json();
      } catch (error) {
        console.error('Error loading trackers.json:', error);
        return;
      }

      const settingsMenu = document.getElementById('settingsMenu');
      const settingsToggle = document.getElementById('settingsToggle');
      const sourceInput = document.getElementById('sourceInput');
      const targetInput = document.getElementById('targetInput');
      const sourceDropdown = document.getElementById('sourceDropdown');
      const targetDropdown = document.getElementById('targetDropdown');      
      const maxJumpsInput = document.getElementById('maxJumpsInput');
      const maxJumpsRadios = document.querySelectorAll('#maxJumpsRadios input');
      const maxDaysInput = document.getElementById('maxDaysInput');
      const maxDaysRadios = document.querySelectorAll('#maxDaysRadios input');
      const sortRadios = document.querySelectorAll('#sortRadios input'); 
      
      let sourceDebounceTimer;
      let targetDebounceTimer;
      
      const { routeInfo, unlockInviteClass, abbrList } = data;
      
      let maxJumps = parseInt(localStorage.getItem('maxJumps'), 10);
      let maxDays = parseInt(localStorage.getItem('maxDays'), 10);
      let sortOptionValue = localStorage.getItem('sortOption');

      const urlParams = new URLSearchParams(window.location.search);
      const fromParam = urlParams.get('from');
      const toParam = urlParams.get('to');
      const jumpsParam = parseInt(urlParams.get('jumps'), 10);
      const daysParam = parseInt(urlParams.get('days'), 10);
      const sortParam = urlParams.get('sort');
    
      if (fromParam) sourceInput.value = fromParam;
      if (toParam) targetInput.value = toParam;
      if (!isNaN(jumpsParam)) maxJumps = jumpsParam;
      if (!isNaN(daysParam)) maxDays = daysParam;
      if (sortParam) sortOptionValue = sortParam;
          
      if (isNaN(maxJumps)) maxJumps = 4;
      if (isNaN(maxDays)) maxDays = 720;
      if (!sortOptionValue) sortOptionValue = 'fastest';
      
      const allTrackers = Array.from(new Set(
        Object.keys(routeInfo)
        .flatMap(startKey => [startKey, ...Object.keys(routeInfo[startKey])])
      )).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

      const allTrackersLower = allTrackers.map(t => t.toLowerCase());

      maxJumpsInput.addEventListener('change', (event) => {
        maxJumps = parseInt(event.target.value, 10);
        localStorage.setItem('maxJumps', maxJumps);
        calculateRoute();
      });

      maxDaysInput.addEventListener('change', (event) => {
        maxDays = parseInt(event.target.value, 10);
        localStorage.setItem('maxDays', maxDays);
        calculateRoute();
      });
      
      document.addEventListener('mousedown', (event) => {
        if (
          !sourceDropdown.contains(event.target) &&
          !sourceInput.contains(event.target)
        ) {
          sourceDropdown.style.display = 'none';
        }
      
        if (
          !targetDropdown.contains(event.target) &&
          !targetInput.contains(event.target)
        ) {
          targetDropdown.style.display = 'none';
        }
      });

      [sourceDropdown, targetDropdown].forEach(dropdown => {
        dropdown.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
      });
      
      [sourceInput, targetInput].forEach(input => {
        input.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
      });

      sourceInput.addEventListener('focus', (e) => {
        showAutocomplete(sourceInput, sourceDropdown, e.target.value);
      });

      sourceInput.addEventListener('input', (e) => {
        clearTimeout(sourceDebounceTimer);
        const value = e.target.value;
        sourceDebounceTimer = setTimeout(() => {
          showAutocomplete(sourceInput, sourceDropdown, value);
        }, 150);
      });
      
      targetInput.addEventListener('input', (e) => {
        clearTimeout(targetDebounceTimer);
        const value = e.target.value;
        targetDebounceTimer = setTimeout(() => {
          showAutocomplete(targetInput, targetDropdown, value);
        }, 150);
      });

      targetInput.addEventListener('focus', (e) => {
        showAutocomplete(targetInput, targetDropdown, e.target.value);
      });

      let previousFiltered = [];
      const abbrListLower = {};
      for (const key in abbrList) {
        abbrListLower[key] = abbrList[key].toLowerCase();
      }
      
      function showAutocomplete(input, dropdown, value) {
        const searchTerm = value.toLowerCase().trim();
        if (!searchTerm) {
          dropdown.style.display = 'none';
          return;
        }

        const filtered = [];
        for (let i = 0; i < allTrackers.length; i++) {
          const tracker = allTrackers[i];
          const trackerLower = allTrackersLower[i];
          const abbrLower = abbrListLower[tracker] || '';
          if (trackerLower.includes(searchTerm) || abbrLower.includes(searchTerm)) {
            filtered.push(tracker);
            if (filtered.length >= 20) break;
          }
        }

        const isSame = filtered.length === previousFiltered.length &&
                       filtered.every((t, i) => t === previousFiltered[i] &&
                         ((abbrList[t] || '') === (abbrList[previousFiltered[i]] || '')));
        if (isSame) return;
        previousFiltered = filtered.slice();
      
        dropdown.innerHTML = '';

        filtered.forEach(tracker => {
          const item = document.createElement('div');
          item.className = 'autocomplete-item';
      
          const abbr = abbrList[tracker] ? ` (${abbrList[tracker]})` : '';

          const nameHTML = tracker.replace(new RegExp(`(${searchTerm})`, 'ig'), '<mark>$1</mark>');
          const abbrHTML = abbr.replace(new RegExp(`(${searchTerm})`, 'ig'), '<mark>$1</mark>');
      
          item.innerHTML = nameHTML + abbrHTML;
      
          item.addEventListener('click', () => {
            input.value = tracker;
            dropdown.style.display = 'none';
            calculateRoute();
          });
      
          dropdown.appendChild(item);
        });
      
        dropdown.style.display = filtered.length > 0 ? 'block' : 'none';
      }

      const apiUrl = `https://api.github.com/repos/x4714/private-tracker-route-planner/commits?path=trackers.json`;

      fetch(apiUrl)
        .then(response => response.json())
        .then(data => {
          const commitDate = data[0].commit.committer.date;
          const updateDate = new Date(commitDate).toLocaleDateString();
          document.getElementById('update-time').innerText = `Updated ${updateDate}`;
        })
        .catch(error => {
          console.error('Error fetching commit data:', error);
          document.getElementById('update-time').innerText = 'Update date unavailable';
        });

        function setMaxJumps(value) {
          maxJumpsInput.value = value;
          let matched = false;
          maxJumpsRadios.forEach(r => {
            r.checked = r.value == value;
            if (r.checked) matched = true;
          });
          // Deselect all if no match
          if (!matched) maxJumpsRadios.forEach(r => r.checked = false);
        
          localStorage.setItem('maxJumps', value);
          calculateRoute();
        }

      maxJumpsRadios.forEach(radio => {
        radio.addEventListener('change', () => setMaxJumps(parseInt(radio.value, 10)));
      });
      
      maxJumpsInput.addEventListener('change', () => {
        let val = parseInt(maxJumpsInput.value, 10);
        if (isNaN(val) || val < 1) val = 1;
        setMaxJumps(val);
      });
    
      setMaxJumps(maxJumps);
    
      function setMaxDays(value) {
        maxDaysInput.value = value;
        let matched = false;
        maxDaysRadios.forEach(r => {
          r.checked = r.value == value;
          if (r.checked) matched = true;
        });
        if (!matched) maxDaysRadios.forEach(r => r.checked = false);
      
        localStorage.setItem('maxDays', value);
        calculateRoute();
      }
          
      maxDaysRadios.forEach(radio => {
        radio.addEventListener('change', () => setMaxDays(parseInt(radio.value, 10)));
      });
    
      maxDaysInput.addEventListener('change', () => {
        let val = parseInt(maxDaysInput.value, 10);
        if (isNaN(val) || val < 1) val = 1;
        setMaxDays(val);
      });
    
      setMaxDays(maxDays);
    
      function setSortOption(value) {
        sortRadios.forEach(r => r.checked = r.value === value);
        localStorage.setItem('sortOption', value);
        calculateRoute();
      }
    
      sortRadios.forEach(radio => {
        radio.addEventListener('change', () => setSortOption(radio.value));
      });
    
      setSortOption(sortOptionValue);

      function calculateRoute() {
        const resultsInfo = document.getElementById('resultsInfo');
        const routesGrid = document.getElementById('routesGrid');
        const fragment = document.createDocumentFragment();

        resultsInfo.innerHTML = '';
        routesGrid.innerHTML = '';

        const start = sourceInput.value.trim();
        const end = targetInput.value.trim();

        if (!start && !end) {
          resultsInfo.innerHTML = 'Enter source and/or target tracker to find routes';
          return;
        }

        if (start && end && start === end) {
          resultsInfo.innerHTML = 'One account per lifetime!';
          return;
        }

        let allRoutes = [];

        if (!start || start === '') {
          if (end && routeInfo[end]) {
            resultsInfo.innerHTML = 'Please enter a source tracker';
            return;
          }
          allRoutes = Object.keys(routeInfo)
            .filter(node => routeInfo[node] && routeInfo[node][end])
            .map(node => [node, end]);
        } else if (!end || end === '') {
          if (!routeInfo[start]) {
            resultsInfo.innerHTML = `No official recruitment from ${start}`;
            return;
          }
          allRoutes = Object.keys(routeInfo[start])
            .map(node => [start, node])
            .filter(([from, to]) => routeInfo[from] && routeInfo[from][to]);
        } else {
          if (!routeInfo[start]) {
            resultsInfo.innerHTML = `No official recruitment from ${start}`;
            return;
          }
          allRoutes = findAllRoutes(start, end, maxJumps, maxDays);
        }

        if (allRoutes.length === 0) {
          resultsInfo.innerHTML = 'No routes found';
          return;
        }

        let selectedSort = 'fastest';
        sortRadios.forEach(r => {
          if (r.checked) selectedSort = r.value;
        });
        
        if (selectedSort === 'fastest') {
          allRoutes = allRoutes.sort((a, b) => {
            const timeA = calculateRouteDays(a);
            const timeB = calculateRouteDays(b);
            if (timeA !== timeB) return timeA - timeB;
            return a.length - b.length;
          });
        } else if (selectedSort === 'fewestJumps') {
          allRoutes = allRoutes.sort((a, b) => {
            if (a.length !== b.length) return a.length - b.length;
            return calculateRouteDays(a) - calculateRouteDays(b);
          });
        }

        resultsInfo.innerHTML = `Found ${allRoutes.length} route${allRoutes.length !== 1 ? 's' : ''}`;

        allRoutes.forEach((route, index) => {
          fragment.appendChild(createRouteCard(route, index + 1));
        });
        routesGrid.appendChild(fragment);
      }

      function createRouteCard(route, routeNumber) {
        const card = document.createElement('div');
        card.className = 'route-card';

        const abbreviatedRoute = route.map(node => abbrList[node] || node);
        const displayRoute = abbreviatedRoute.join(' → ');

        const totalDays = calculateRouteDays(route);
        const jumps = route.length - 1;

        let stepsHTML = '';
        route.forEach((node, index) => {
          if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
            const nextNode = route[index + 1];
            const maxDays = getMaxDays(node, nextNode);
            const routeData = routeInfo[node][nextNode];
            const requirement = routeData.reqs || 'No requirement';
            const lastActivity = routeData.updated || 'Unknown';
            const activeStatus = routeData.active || 'Unknown';

            // Determine badge class
            let statusClass = 'status-unknown';
            if (activeStatus.toLowerCase() === 'yes') statusClass = 'status-recruiting';
            if (activeStatus.toLowerCase() === 'no') statusClass = 'status-closed';

            const daysDisplay = maxDays === null ? 'Unknown' : `${maxDays}d`;

            stepsHTML += `
              <div class="route-step">
                <div class="route-step-header">
                  <span>${node} → ${nextNode}</span>
                  <span class="route-step-days">${daysDisplay}</span>
                  <span class="status-badge ${statusClass}">${activeStatus === 'Yes' ? 'Recruiting' : activeStatus === 'No' ? 'Closed' : 'Unknown'}</span>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Class needed:</div>
                  <div class="route-step-value">${unlockInviteClass[node] ? unlockInviteClass[node][1] : 'N/A'}</div>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Requirements:</div>
                  <div class="route-step-value">${requirement}</div>
                </div>
                <div class="route-step-detail">
                  <div class="route-step-label">Last checked:</div>
                  <div class="route-step-value">${lastActivity}</div>
                </div>
              </div>
            `;
          }
        });

        card.innerHTML = `
          <div class="route-header">${displayRoute}</div>
          <div class="route-summary">
            <span>Route #${routeNumber}</span>
            <span>${jumps} jump${jumps !== 1 ? 's' : ''} · ${totalDays} days</span>
          </div>
          ${stepsHTML}
        `;

        return card;
      }

      function calculateRouteDays(route) {
        return route.reduce((sum, node, index) => {
          if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
            const days = getMaxDays(node, route[index + 1]);
            return sum + (days === null ? 0 : days);
          }
          return sum;
        }, 0);
      }

      function findAllRoutes(start, end, maxJumps = 5, maxDays = 1080) {
        const result = [];
        const stack = [[start, [start], 0]];
      
        while (stack.length) {
          const [node, route, days] = stack.pop();
      
          if (route.length > maxJumps + 1) continue;
          if (days > maxDays) continue; // early cutoff
      
          if (node === end) {
            result.push(route);
            continue;
          }
      
          const neighbors = Object.entries(routeInfo[node] || {});
          for (const [next, _] of neighbors) {
            if (!route.includes(next)) {
              const maxDaysToNext = getMaxDays(node, next);
              const newDays = (maxDaysToNext === null ? days : days + maxDaysToNext);
              stack.push([next, [...route, next], newDays]);
            }
          }
        }
      
        return result;
      }

      function getMaxDays(start, end) {
        const routeData = routeInfo[start] && routeInfo[start][end];
        const days1 = routeData && routeData.days !== undefined ? routeData.days : null;
        const days2 = (unlockInviteClass[start] && unlockInviteClass[start][0]) || 0;

        if (days1 === null) return null;
        
        return Math.max(days1, days2);
      }

      // Initial calculation
      calculateRoute();

      window.addEventListener('error', (e) => {
        console.error('JS Error:', e.message, e.filename, e.lineno);
      });

    function updateURL() {
      const params = new URLSearchParams();
      if (sourceInput.value) params.set('from', sourceInput.value);
      if (targetInput.value) params.set('to', targetInput.value);
      params.set('jumps', maxJumps);
      params.set('days', maxDays);
      const selectedSort = Array.from(sortRadios).find(r => r.checked)?.value || 'fastest';
      params.set('sort', selectedSort);
      history.replaceState(null, '', '?' + params.toString());
    }
  
    sourceInput.addEventListener('input', updateURL);
    targetInput.addEventListener('input', updateURL);
    maxJumpsInput.addEventListener('change', updateURL);
    maxDaysInput.addEventListener('change', updateURL);
    sortRadios.forEach(r => r.addEventListener('change', updateURL));

    });
  </script>
</body>
</html>

